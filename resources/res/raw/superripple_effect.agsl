uniform shader img;

uniform float density;
uniform float2 size;
uniform int count;
uniform float4 radius;

uniform float[10] t;
uniform float[10] centerX;
uniform float[10] centerY;
uniform float[10] intensity;

float sdfRoundedBox(in float2 p, in float2 s, in float4 r) {
    r.xy = (p.x > 0.0) ? r.xy : r.zw;
    r.x  = (p.y > 0.0) ? r.x  : r.y;
    float2 q = abs(p) - s + r.x;
    return min(max(q.x, q.y), 0.0) + length(max(q, 0.0)) - r.x;
}

//float3 rippleOffset_shadertoy(float2 uv, float2 center, float intensity, float time) {
//    const float freq = 1.0;
//    const float speed = 8.;
//    const float strength = 0.2;
//    const float dropOff = 12.;
//    const float duration = 0.8;
//    const float initialStrength = 3.0;
//    const float fallOffStrength = 1.;
//
//    uv = (uv - center) * 2.;
//    uv.x *= size.x / size.y;
//
//    float dist = length(uv);
//    float depth = cos((dist * freq) - (time * speed));
//
//    if (dist > dropOff) {
//        depth = 0.;
//    } else {
//        depth *= dropOff - dist;
//    }
//
//    depth *= 1. - time;
//    depth *= smoothstep(1. - time * (1.0 * intensity * initialStrength), 1., 1. - dist);
//    depth *= smoothstep(0., time * (1.0 * intensity * fallOffStrength), dist);
//
//    float2 offset = (-abs(normalize(uv)) * -depth * (intensity * strength * 0.05));
//    float add = .4 * max(0.0, depth) * strength;
//
//    return float3(offset, add);
//}

float3 rippleOffset_ios(float2 position, float2 center, float intensity, float time) {
    float speed = (intensity > 1.0 ? 1200.0 : 1500.0) * density;
    float frequency = (intensity > 1.0 ? 17.0 : 15.0);
    float amplitude = (intensity > 1.0 ? 15.0 : 30.0) * density * intensity;
    float decay = intensity > 1.0 ? 5.5 : 10.0;

    float dist = length(position - center);
    if (dist < 9.0 * density) return float3(0.0);

    float delay = dist / speed;
    time -= delay;
    time = max(0.0, time);

    float rippleAmount = amplitude * sin(frequency * time) * exp(-decay * time);
    float absRippleAmount = abs(rippleAmount);
    if (rippleAmount < 0.0) {
        rippleAmount = -absRippleAmount;
    } else {
        rippleAmount = absRippleAmount;
    }

    if (dist <= 80.0 * density) {
        rippleAmount *= mix(0.4, 1.0, clamp((dist - 60.0 * density) / (20.0 * density), 0.0, 1.0));
    }

    return float3(
        normalize(position - center) * rippleAmount,
        (intensity > 1.0 ? 0.17 : 0.11) * (rippleAmount / amplitude)
    );
}

half4 main(in float2 fragCoord) {
    float add = 0.0;
    float2 offset = float2(0.0);
    for (int i = 0; i < 10; ++i) {
        if (i >= count) break;
        float3 ripple = rippleOffset_ios(fragCoord, float2(centerX[i], centerY[i]), intensity[i], t[i]);
        offset += ripple.xy;
        add += ripple.z;
    }
    float2 uv = fragCoord / size;
    uv *= size;
    uv += offset;
    if (sdfRoundedBox(uv - size * .5, size * .5, radius) > 0.0)
        return half4(0.0, 0.0, 0.0, 1.0);
    return img.eval(uv) + half4(add, add, add, 1.);
}